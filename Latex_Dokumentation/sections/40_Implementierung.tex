\chapter{Implementierung}

\section{Chess}
\sectionauthor{\oliver}

Schach ist eins der bekanntesten und gleichzeitig eins der anspruchsvollsten
Spiele der Welt. Aufgrund der Komplexität und benötigten Weitsichtigkeit
schaffte es erst 1996 der Schachcomputer "Deep Blue" vom IBM den damalig
amtierenden Schachweltmeister Garro Kasparow zu besiegen. \change{Beleg?}
Heutzutage existieren viele Implementierungen fähiger Schachprogramme und KI.
In diesem Projekt wurde die Schachengine "Carballo" verwendet. \unsure{Kommt
das hier überhaupt hin? Wenn ja, mehr?} \info{Joa, vielleicht etwas mehr
Überleitung}

\subsection{Das Spielfeld}

Für das klassische karierte Spielfeld wurde die Klasse
\code{CheckeredGameboardView} erstellt, welche wie der Name schon sag von der
Androidklasse \code{View} erbt. Hauptbestandteil ist ein Zweidimensionales
Array aus Androids\code{Rect}, welche die einzelnen Felder des Spielfelds
darstellen. Diese werden nach Aufruf von \code{onSizeChanged} der Größe des
Displays angepasst und je nach Einstellung um die Stärke des gewünschten Randes
verschoben, sodass auf jedem Gerät ein identisches Spielerlebnis erzegut werden
kann. Um bei einem Touch auf die View zu ermitteln, auf welches der Felder
getippt wurde setzt die Methode \code{getSquareFromTouch(int x, int y)} die in
\code{Rect} mitgelieferte Funktion \code{contains(int x, int y)} ein und gibt
die Array-Koordinaten des gesuchten Kastens zurück. Bei der Kolorierung und
Markierung der Felder bezieht sich die Klasse auf die in den Einstellungen
gespeicherten Werte.

\subsection{Der Chesswrapper}

In der Welt der Informatik sucht man den Begriff \emph{"Langlebig"} vergeblich,
permanent werden Module und Codeabschnitte verändert und ausgetauscht. Auch bei
der Spielesammlung sind solche Modifikationen vorgekommen und werden wohl in
absehbarer Zeit wieder passieren. Aus diesem Grund ist die Schachlogik nur über
eine einzige Schnittstelle zugänglich, dem \code{ChessWrapper}. Dieser
umschließt alle benötigten Funktionen der verwendeten Schachbibliothek und
erleichtert das Austauschen der selbigen beachtlich. Neben grundlegenden
Funktionen wie das ausgeben der aktuellen Figurenaufstellung und das setzen von
Schachzügen beinhaltet der Wrapper auch die Funktionen der künstlichen
Intelligenz, welche sich in der selben Bibliothek befindet. In zukünftigen
Versionen werden diese Funktionen getrennt behandelt, um allgemein geltenden
Codemetriken gerecht zu werden.\unsure{Soll das so bleiben oder kommt das so
rüber als ob wir das schlecht gemacht haben?} \info{Was meinst du damit, es
wird getrennt behandelt? Haben wir da je darüber geredet?}

\section{Kartenspiele}
\sectionauthor{\philipp}
Wir implementierten drei Kartenspiele in unserer Applikation, MauMau, Bauernkrieg und Offiziersschafkopf (auch: aufgelegtes Schafkopf). Letzteres ist für 2 Spieler ausgelegt und vorallem in Bayern bekannt, trotz der relativ komplexen Art in Schafkopf Stiche zu erzielen, war uns die JDroid Bibliothek eine große Hilfe. Diese Bibliothek brachte auch MauMau und Bauernkrieg bereits mit, welche beide lediglich abgeändert werden mussten.
Aus diesem Grund fokussieren wir uns in diesem Teil auf Schafkopf, zumal in diesem Spiel alles verwendet wird, was auch in den anderen beiden verwendet wird.
Jedem Spiel ist ein Menu mit \emph{Start} Knopf vorgeschalten, in welchem man die Regeln nochmals lesen könnte.

\subsection{Ranks und Suits}
Zum weiteren Verständnis, zeige ich hier die in Schafkopf genutzten enums auf, auf denen das Deck basiert.

\code{public enum Suit{\\EICHEL, GRUEN, HERZ, SCHELLEN}\\public enum Rank{\\ASS, OBER, UNTER, ZEHN, KOENIG, NEUN, ACHT, SIEBEN}}

\subsection{Schafkopf Board}
Wir nutzen zwei Klassen für das Schafkopf Spiel \code{schafkopf} und \code{initiateGame}.
\code{schafkopf} erbt von \code{CardGame}, einer Bibliotheksklasse, welche alle wichtigen Methoden von JDroid implementiert. Bei Aufruf der Schafkopf Klasse wird das Board erstellt und in \code{main()} zunächst das Deck und ein initiateGame Objekt auf dessen Basis. InitiateGame initialisiert alle nötigen Hände, sprich Bids, Stacks und Hands und weist ihnen Locations zu. Ist dies abgeschlossen, wird \code{initPlayers()} und \code{setPlayerMove()} aufgerufen um fortzufahren.

\subsection{initPlayers()}
Diese Methode ist das Herzstück unserer Kartenspiele. Hat derjenige Spieler, der eben an der Reihe ist, eine Karte ausgewählt und auf den Bid transferiert, dann gibt es nun zwei Möglichkeiten.
\begin{itemize}
\item 1. Auf beiden Bids befinden sich Karten und der Stich wird ausgewertet
\item 2. Auf nur einem Bid befindet sich eine Karte, \code{setPlayermove(otherPlayer)} wird 		 aufgerufen
\end{itemize}
Im ersten Falle wird \code{sticht()} aufgerufen und getestet wer den Stich macht.
Die Karten werden auf den Stack des Gewinners transferiert, es wird getestet ob das Spiel vorbei ist und die Kartenzahl wird geupdatet. Zuletzt wird noch der Playermove auf den Gewinner gesetzt und er darf wieder eine Karte ausspielen.

\subsection{Stiche berechnen}

\subsection{UpdateCardNumber}

\subsection{GameOver}



\section{Die Spielstände}
\sectionauthor{\leonard}

Wie schon in der Architektur beschrieben, werden für die Spielstände die Klassen 
\code{SavegameStorage}, \code{Savegame} und \code{SavegameAdapter} benutzt.
Im Folgenden wird näher auf die Klassen eingegangen.

\subsection{SavegameStorage}
ist in einem Singleton-Pattern geschrieben. Gründe dafür sind einerseits, dass 
der Speicher nur von einer Instanz aufgerufen werden sollte, damit keine 
Speicher- oder Ladefehler entstehen. Andererseits ist es wichtig zu kontrollieren, 
wann und wo auf den Speicher zugegriffen wird. 
\begin{lstlisting}[caption={SavegameStorage Singleton},captionpos=b]
     public static SavegameStorage getInstance() {
        if (instance == null) {
            synchronized (SavegameStorage.class) {
                if (instance == null) {
                    instance = new SavegameStorage();
                }
            }
        }
        return instance;
     }
\end{lstlisting}
\code{Synchronized} wird hier verwendet um das Pattern \emph{Thread-Sicher} zu 
machen.

\paragraph{Der Speicherungsvorgang} erfolgt durch die Nutzung des Interfaces  
\textbf{SharedPreferences} in Android. Dieses ermöglicht das Speichern und Laden von 
\emph{Key-Value} Paaren auf dem Android-Gerät. Zur Laufzeit werden alle Spielstände 
als \textbf{ArrayList\textless Savegame\textgreater} gehandhabt. Sobald etwas 
gespeichert werden soll, wird die Liste dementsprechend geändert und durch 
\textbf{Gson} in \textbf{JSON} serialisiert und per \textbf{SharedPreferences} 
unter einem \emph{Key} als String gespeichert.\\
Beim Laden erfolgt der Aufruf des \textbf{JSON}-Strings wieder druch den selben 
\emph{Key} wie beim speichern, dann wird der String deserialisiert und wieder als 
\textbf{ArrayList\textless Savegame\textgreater} benutzt.







